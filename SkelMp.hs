module SkelMp where

-- Haskell module generated by the BNF converter

import AbsMp
import ErrM
import qualified AST as A
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> String
transIdent x = case x of
  Ident string -> string

transProg :: Prog -> A.M_prog
transProg x = case x of
  ProgBlock block -> A.M_prog(transBlock block)

transBlock :: Block -> ([A.M_decl],[A.M_stmt])
transBlock x = case x of
  Block1 declarations programbody -> (transDeclarations declarations, transProgram_body programbody)

transDeclarations :: Declarations -> [A.M_decl]
transDeclarations x = case x of
  Declarations1 declaration declarations -> (transDeclaration declaration : transDeclarations declarations)
  Declarations2 -> []

transDeclaration :: Declaration -> A.M_decl
transDeclaration x = case x of
  DeclarationVar_declaration vardeclaration -> transVar_declaration vardeclaration
  DeclarationFun_declaration fundeclaration -> transFun_declaration fundeclaration

transVar_declaration :: Var_declaration -> A.M_decl
transVar_declaration x = case x of
  Var_declaration1 ident arraydimensions type_ -> A.M_var (transIdent ident, transArray_dimensions arraydimensions, transType type_)

transType :: Type -> A.M_type
transType x = case x of
  Type_int -> A.M_int
  Type_real -> A.M_real
  Type_bool -> A.M_bool

transArray_dimensions :: Array_dimensions -> [A.M_expr]
transArray_dimensions x = case x of
  Array_dimensions1 expr arraydimensions -> transExpr expr : transArray_dimensions arraydimensions
  Array_dimensions2 -> []

transFun_declaration :: Fun_declaration -> A.M_decl
transFun_declaration x = case x of
  Fun_declaration1 ident paramlist type_ funblock -> A.M_fun(transIdent ident, transParam_list paramlist, transType type_, fst (transFun_block funblock), snd (transFun_block funblock))

transFun_block :: Fun_block -> ([A.M_decl],[A.M_stmt])
transFun_block x = case x of
  Fun_block1 declarations funbody -> (transDeclarations declarations, transFun_body funbody)

transParam_list :: Param_list -> [(String,Int,A.M_type)]
transParam_list x = case x of
  Param_list1 parameters -> transParameters parameters

transParameters :: Parameters -> [(String,Int,A.M_type)]
transParameters x = case x of
  Parameters1 basicdeclaration moreparameters -> transBasic_declaration basicdeclaration : transMore_parameters moreparameters
  Parameters2 -> []

transMore_parameters :: More_parameters -> [(String,Int,A.M_type)]
transMore_parameters x = case x of
  More_parameters1 basicdeclaration moreparameters -> transBasic_declaration basicdeclaration : transMore_parameters moreparameters
  More_parameters2 -> []

transBasic_declaration :: Basic_declaration -> (String,Int,A.M_type)
transBasic_declaration x = case x of
  Basic_declaration1 ident basicarraydimensions type_ -> (transIdent ident, transBasic_array_dimensions basicarraydimensions, transType type_)

transBasic_array_dimensions :: Basic_array_dimensions -> Int
transBasic_array_dimensions x = case x of
  Basic_array_dimensions1 basicarraydimensions -> 0
  Basic_array_dimensions2 -> 0

transProgram_body :: Program_body -> [A.M_stmt]
transProgram_body x = case x of
  Program_body1 progstmts -> transProg_stmts progstmts
  Program_bodyProg_stmts progstmts -> transProg_stmts progstmts

transFun_body :: Fun_body -> [A.M_stmt]
transFun_body x = case x of
  Fun_body1 progstmts expr -> transProg_stmts progstmts ++ [A.M_return(transExpr expr)]

transProg_stmts :: Prog_stmts -> [A.M_stmt]
transProg_stmts x = case x of
  Prog_stmts1 progstmt progstmts -> transProg_stmt progstmt : transProg_stmts progstmts
  Prog_stmts2 -> []

transProg_stmt :: Prog_stmt -> A.M_stmt
transProg_stmt x = case x of
  Prog_stmt1 expr progstmt1 progstmt2 -> A.M_cond(transExpr expr, transProg_stmt progstmt1, transProg_stmt progstmt2)
  Prog_stmt2 expr progstmt -> A.M_while (transExpr expr, transProg_stmt progstmt)
  Prog_stmt3 identifier -> A.M_read (transIdentifier identifier)
  Prog_stmt4 identifier expr -> A.M_ass (fst (transIdentifier identifier), snd (transIdentifier identifier), transExpr expr)
  Prog_stmt5 expr -> A.M_print (transExpr expr)
  Prog_stmt6 block -> A.M_block (transBlock block)

transIdentifier :: Identifier -> (String, [A.M_expr])
transIdentifier x = case x of
  Identifier1 ident arraydimensions -> (transIdent ident, transArray_dimensions arraydimensions)

transExpr :: Expr -> A.M_expr
transExpr x = case x of
  Expr1 expr bintterm -> A.M_app(A.M_or,[transExpr expr, transBint_term bintterm])
  ExprBint_term bintterm -> transBint_term bintterm

transBint_term :: Bint_term -> A.M_expr
transBint_term x = case x of
  Bint_term1 bintterm bintfactor -> A.M_app(A.M_and,[transBint_term bintterm,transBint_factor bintfactor])
  Bint_termBint_factor bintfactor -> transBint_factor bintfactor

transBint_factor :: Bint_factor -> A.M_expr
transBint_factor x = case x of
  Bint_factor1 bintfactor -> A.M_app(A.M_not,[transBint_factor bintfactor])
  Bint_factor2 intexpr1 compareop intexpr2 -> A.M_app(transCompare_op compareop,[transInt_expr intexpr1, transInt_expr intexpr2])
  Bint_factorInt_expr intexpr -> transInt_expr intexpr

transCompare_op :: Compare_op -> A.M_operation
transCompare_op x = case x of
  Compare_op1 -> A.M_eq
  Compare_op2 -> A.M_lt
  Compare_op3 -> A.M_gt
  Compare_op4 -> A.M_le
  Compare_op5 -> A.M_ge

transInt_expr :: Int_expr -> A.M_expr
transInt_expr x = case x of
  Int_expr1 intexpr addop intterm -> A.M_app(transAddop addop,[transInt_expr intexpr, transInt_term intterm])
  Int_exprInt_term intterm -> transInt_term intterm

transAddop :: Addop -> A.M_operation
transAddop x = case x of
  Addop1 -> A.M_add
  Addop2 -> A.M_sub

transInt_term :: Int_term -> A.M_expr
transInt_term x = case x of
  Int_term1 intterm mulop intfactor -> A.M_app(transMulop mulop, [transInt_term intterm, transInt_factor intfactor])
  Int_termInt_factor intfactor -> transInt_factor intfactor

transMulop :: Mulop -> A.M_operation
transMulop x = case x of
  Mulop1 -> A.M_mul
  Mulop2 -> A.M_div

transInt_factor :: Int_factor -> A.M_expr
transInt_factor x = case x of
  Int_factor1 expr -> transExpr expr
  Int_factor2 ident basicarraydimensions -> A.M_size(transIdent ident, transBasic_array_dimensions basicarraydimensions)
  Int_factor3 expr -> A.M_app(A.M_float, [transExpr expr])
  Int_factor4 expr -> A.M_app(A.M_floor, [transExpr expr])
  Int_factor5 expr -> A.M_app(A.M_ceil, [transExpr expr])
  Int_factor6 ident modifierlist -> idOrFun (transModifier_list modifierlist) (transIdent ident)
  Int_factorInteger integer -> A.M_ival (integer)
  Int_factorDouble double -> A.M_rval (double)
  Int_factor_true -> A.M_bval True
  Int_factor_false -> A.M_bval False
  Int_factor7 intfactor -> A.M_app(A.M_neg, [transInt_factor intfactor])

transModifier_list :: Modifier_list -> A.M_expr
transModifier_list x = case x of
  Modifier_list1 arguments -> A.M_app (A.M_fn "tmp", transArguments arguments)
  Modifier_listArray_dimensions arraydimensions -> A.M_id ("tmp", transArray_dimensions arraydimensions)

transArguments :: Arguments -> [A.M_expr]
transArguments x = case x of
  Arguments1 expr morearguments -> transExpr expr : transMore_arguments morearguments
  Arguments2 -> []

transMore_arguments :: More_arguments -> [A.M_expr]
transMore_arguments x = case x of
  More_arguments1 expr morearguments -> transExpr expr : transMore_arguments morearguments
  More_arguments2 -> []

idOrFun (A.M_id (_,exprs)) n = (A.M_id(n,exprs))
idOrFun (A.M_app (_,exprs)) n = (A.M_app((A.M_fn n),exprs))
